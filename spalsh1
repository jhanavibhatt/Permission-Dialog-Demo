package amplify.fill.customView

import amplify.fill.R
import amplify.fill.customView.ResizeCallbackImageView.OnSizeChangedListener
import amplify.fill.utils.ImageUtils
import android.app.Activity
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Paint
import android.graphics.Point
import android.graphics.PorterDuff
import android.graphics.PorterDuffXfermode
import android.graphics.drawable.BitmapDrawable
import android.graphics.drawable.Drawable
import android.os.Handler // Added import for Handler
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.animation.AlphaAnimation
import android.view.animation.Animation
import android.view.animation.ScaleAnimation
import android.widget.FrameLayout
import android.widget.ImageView
import androidx.appcompat.app.ActionBar
import androidx.core.content.ContextCompat

class Splash(activity: Activity, actionBar: androidx.appcompat.app.ActionBar?) {
    private var mIvSplash: ResizeCallbackImageView? = null

    private var mSplashContainer: ViewGroup? = null
    private var mSplashImageBackground: View? = null

    private var mSplashImage: Drawable? = null
    private var mSplashBackgroundColor = 0
    private var mSplashBackgroundPicture: Drawable? = null

    private val mActionBar: ActionBar? = actionBar

    private var mScreenWidth = 0
    private var mScreenHeight = 0

    private var useColorInSplashBackground = false

    private val mContext: Context = activity.applicationContext

    private var mPivotXOffset = 0
    private var mPivotYOffset = 0

    enum class AnimationType {
        TYPE_1,
        TYPE_2,
    }

    private var mAnimationType = AnimationType.TYPE_1

    init {
        initScreenSize(activity)
        replaceRootContent(activity)
        initViews()
    }

    /**
     * Initializing variables, which are responsible for screen width and height.
     *
     * @param activity Parent activity before which we should show splash screen
     */
    private fun initScreenSize(activity: Activity) {
        val display = activity.windowManager.defaultDisplay
        val screenSize = Point()
        display.getSize(screenSize)
        mScreenWidth = screenSize.x
        mScreenHeight = screenSize.y
    }

    /**
     * Removing content from root ViewGroup, copying it to another ViewGroup, which contains splash screen,
     * that higher in the hierarchy.
     *
     * @param activity Parent activity before which we should show splash screen
     */
    private fun replaceRootContent(activity: Activity) {
        // **NOTE: android.R.id.content is a system ID for the activity's root content view.**
        // This is usually fine, but ensure it's not conflicting with any other R.id.content you might have.
        val content = (activity
            .findViewById<View>(android.R.id.content) as ViewGroup).getChildAt(0) as ViewGroup

        mSplashContainer = LayoutInflater.from(content.context)
            .inflate(R.layout.activity_fill, null, false) as ViewGroup?

        val root = content.parent as ViewGroup
        root.removeView(content)

        val newContainer = FrameLayout(root.context)
        newContainer.addView(content)
        newContainer.addView(mSplashContainer)

        root.addView(newContainer)

        mSplashContainer!!.visibility = View.GONE
    }

    /**
     * Method is responsible for initializing all views, which are used is splash screen
     */
    private fun initViews() {
        // Fix: Use correct R.id references from your splash_layout.xml
        mIvSplash =
            mSplashContainer!!.findViewById<View>(R.id.splash_view1) as ResizeCallbackImageView
        mSplashImageBackground = mSplashContainer!!.findViewById<View>(R.id.splash_image_background)

        // Fix: Use correct R.color references. Make sure these colors are defined in your colors.xml
        mSplashImageBackground!!.setBackgroundColor(
            ContextCompat.getColor(
                mContext,
                R.color.white // Assuming you have this defined in your app's colors.xml
            )
        )
        mSplashBackgroundColor = ContextCompat.getColor(mContext, R.color.white) // Assuming this is defined or available
        mSplashImage = ContextCompat.getDrawable(mContext, R.drawable.ic_fill_new) // Assuming this is defined in your drawables

        mIvSplash!!.scaleX = D_FROM
        mIvSplash!!.scaleY = D_FROM

        processMask()
    }

    /**
     * If activity contains action bar this method toggles it (shows or hides).
     *
     * @param show Boolean which is responsible for toggling. (true - to show)
     */
    private fun toggleActionbar(show: Boolean) {
        if (mActionBar != null) {
            if (show) {
                mActionBar.show()
            } else {
                mActionBar.hide()
            }
        }
    }

    /**
     * This method is responsible for cutting splash image from background to make transparent hole
     */
    private fun processMask() {
        val mask: Bitmap = mSplashImage?.let { drawableToBitmap(it) } ?: return

        val drawable = ContextCompat.getDrawable(mContext, R.drawable.ic_fill_new)
        val bitmap = drawable?.let { drawableToBitmap(it) }

        val result = Bitmap.createBitmap(mScreenWidth, mScreenHeight, Bitmap.Config.ARGB_8888)

        /**
         * Finding left and top coordinates for drawing mask in the center of ImageView
         */
        val left = (mScreenWidth / 2 - mask.width / 2).toFloat()
        val top = (mScreenHeight / 2 - mask.height / 2).toFloat()

        val canvas = Canvas(result)
        val paint = Paint(Paint.ANTI_ALIAS_FLAG)

        if (useColorInSplashBackground || mSplashBackgroundPicture == null) {
            canvas.drawColor(mSplashBackgroundColor)
        } else {
            val tmpSplashBitmap = (mSplashBackgroundPicture as BitmapDrawable).bitmap
            val background: Bitmap =
                ImageUtils.scaleCenterCrop(tmpSplashBitmap, mScreenHeight, mScreenWidth)
            canvas.drawBitmap(background, 0f, 0f, paint) // Use paint for consistent rendering
        }

        paint.setXfermode(PorterDuffXfermode(PorterDuff.Mode.DST_OUT))
        canvas.drawBitmap(mask, left, top, paint)

        mIvSplash!!.setImageBitmap(result)

        mIvSplash!!.scaleType = ImageView.ScaleType.CENTER_CROP
    }
    fun drawableToBitmap(drawable: Drawable): Bitmap {
        if (drawable is BitmapDrawable) {
            return drawable.bitmap
        }

        val width = if (drawable.intrinsicWidth > 0) drawable.intrinsicWidth else 1
        val height = if (drawable.intrinsicHeight > 0) drawable.intrinsicHeight else 1

        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(bitmap)
        drawable.setBounds(0, 0, canvas.width, canvas.height)
        drawable.draw(canvas)
        return bitmap
    }

    /**
     * Starts animations
     */
    private fun startAnimationType1() {
        val midW = (mIvSplash!!.width shr 1).toFloat()
        val midH = (mIvSplash!!.height shr 1).toFloat()

        val scaleUpAnim =
            ScaleAnimation(U_FROM, U_TO, U_FROM, U_TO, midW + mPivotXOffset, midH + mPivotYOffset)
        val scaleDownAnim = ScaleAnimation(D_FROM, D_TO, D_FROM, D_TO, midW, midH)
        val alphaSplashImageAnimation = AlphaAnimation(1f, 0f)

        scaleDownAnim.duration = (SCALE_D_DR_TYPE_1 * DR_FACTOR).toLong()
        scaleUpAnim.duration = (SCALE_UP_DR_TYPE_1 * DR_FACTOR).toLong()
        alphaSplashImageAnimation.duration = ALPHA_DR_TYPE_1.toLong()

        scaleDownAnim.setAnimationListener(object : CAnimatorListener() {
            override fun onAnimationEnd(animation: Animation) {
                mSplashImageBackground!!.startAnimation(alphaSplashImageAnimation)
                mIvSplash!!.startAnimation(scaleUpAnim)
            }
        })

        scaleUpAnim.setAnimationListener(object : CAnimatorListener() { // CAnimatorListener not defined, will be an error
            override fun onAnimationEnd(animation: Animation) {
                super.onAnimationEnd(animation)
                mSplashContainer!!.visibility = View.GONE
                toggleActionbar(true)
                isOneShot = true
            }
        })

        initSplashSizeBeforeScaleAnim()

        mIvSplash!!.startAnimation(scaleDownAnim)
    }

    private fun startAnimationType2() {
        val midW = (mIvSplash!!.width shr 1).toFloat()
        val midH = (mIvSplash!!.height shr 1).toFloat()

        val scaleUpAnim =
            ScaleAnimation(U_FROM, U_TO, U_FROM, U_TO, midW + mPivotXOffset, midH + mPivotYOffset)
        val scaleDownAnim = ScaleAnimation(D_FROM, D_TO, D_FROM, D_TO, midW, midH)
        val alphaSplashImageAnimation = AlphaAnimation(1f, 0f)

        scaleDownAnim.duration = (SCALE_D_DR_TYPE_2 * DR_FACTOR).toLong()
        scaleUpAnim.duration = (SCALE_UP_DR_TYPE_2 * DR_FACTOR).toLong()
        alphaSplashImageAnimation.duration = (ALPHA_DR_TYPE_2 * DR_FACTOR).toLong()

        alphaSplashImageAnimation.setAnimationListener(object : CAnimatorListener() { // CAnimatorListener not defined, will be an error
            override fun onAnimationEnd(animation: Animation) {
                mSplashImageBackground!!.visibility = View.GONE

                initSplashSizeBeforeScaleAnim()

                mIvSplash!!.startAnimation(scaleDownAnim)
            }
        })

        scaleDownAnim.setAnimationListener(object : CAnimatorListener() { // CAnimatorListener not defined, will be an error
            override fun onAnimationEnd(animation: Animation) {
                mIvSplash!!.startAnimation(scaleUpAnim)
            }
        })

        scaleUpAnim.setAnimationListener(object : CAnimatorListener() { // CAnimatorListener not defined, will be an error
            override fun onAnimationEnd(animation: Animation) {
                mSplashContainer!!.visibility = View.GONE
                toggleActionbar(true)
                isOneShot = true
            }
        })

        mSplashImageBackground!!.startAnimation(alphaSplashImageAnimation)
    }

    /**
     * Should be used before first scale animation for restoring splash scale to normal. Is used for avoiding flashing.
     */
    private fun initSplashSizeBeforeScaleAnim() {
        mIvSplash!!.scaleX = D_TO
        mIvSplash!!.scaleY = D_TO
    }

    private fun setSplashImage(splashImage: Drawable) {
        this.mSplashImage = splashImage

        processMask()
    }

    private fun setSplashImageColor(color: Int) {
        mSplashImageBackground!!.setBackgroundColor(color)
    }

    private fun setBackgroundColor(color: Int) {
        this.mSplashBackgroundColor = color

        processMask()
    }

    private fun setBackgroundImage(image: Drawable) {
        this.mSplashBackgroundPicture = image

        processMask()
    }

    private fun setPivotXOffset(offset: Int) {
        this.mPivotXOffset = offset
    }

    private fun setPivotYOffset(offset: Int) {
        this.mPivotYOffset = offset
    }

    private fun setUseColorInSplashBackground(useColorInSplashBackground: Boolean) {
        this.useColorInSplashBackground = useColorInSplashBackground
    }

    private fun setAnimationType(type: AnimationType) {
        this.mAnimationType = type
    }

    /**
     * Method is responsible for performing splash screen
     */
    fun perform() {
        if (hasBeenPerformed) {
            return
        }

        hasBeenPerformed = isOneShot

        toggleActionbar(false)
        if (mSplashContainer != null) {
            mIvSplash!!.setOnSizeChangedListener(object : OnSizeChangedListener {
                override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
                    Handler().postDelayed(Runnable { startAnimation() }, START_OFFSET)
                }
            })
        }
    }

    /**
     * Starts specified animation type. If type was not set, then starts default animation (TYPE_1)
     */
    private fun startAnimation() {
        when (mAnimationType) {
            AnimationType.TYPE_1 -> startAnimationType1()
            AnimationType.TYPE_2 -> startAnimationType2()
        }
    }

    class Builder(activity: Activity, actionBar: androidx.appcompat.app.ActionBar?) {
        private val mSplashInstance = Splash(activity, actionBar)

        fun setSplashImage(splashImage: Drawable): Builder {
            mSplashInstance.setSplashImage(splashImage)
            return this
        }

        fun setSplashImageColor(color: Int): Builder {
            mSplashInstance.setSplashImageColor(color)
            return this
        }

        fun setBackgroundColor(color: Int): Builder {
            mSplashInstance.setUseColorInSplashBackground(true)
            mSplashInstance.setBackgroundColor(color)
            return this
        }

        fun setBackgroundImage(image: Drawable): Builder {
            mSplashInstance.setUseColorInSplashBackground(false)
            mSplashInstance.setBackgroundImage(image)
            return this
        }

        fun setPivotXOffset(offset: Int): Builder {
            mSplashInstance.setPivotXOffset(offset)
            return this
        }

        fun setPivotYOffset(offset: Int): Builder {
            mSplashInstance.setPivotYOffset(offset)
            return this
        }

        fun setOneShotStart(isOneShot: Boolean): Builder {
            Companion.isOneShot = isOneShot
            return this
        }

        fun setAnimationType(type: AnimationType): Builder {
            mSplashInstance.setAnimationType(type)
            return this
        }

        fun create(): Splash {
            return mSplashInstance
        }

        fun perform() {
            mSplashInstance.perform()
        }
    }

    companion object {
        //D - down
        //U - up
        //DR - duration
        private const val D_FROM = 1.2f
        private const val D_TO = 1f
        private const val U_FROM = 1f
        private const val U_TO = 20.0f

        private const val START_OFFSET = 1000L // Changed to Long for postDelayed

        private const val SCALE_D_DR_TYPE_1 = 1000
        private const val SCALE_UP_DR_TYPE_1 = 500
        private const val ALPHA_DR_TYPE_1 = 500

        private const val SCALE_D_DR_TYPE_2 = 300
        private const val SCALE_UP_DR_TYPE_2 = 500
        private const val ALPHA_DR_TYPE_2 = 200

        private const val DR_FACTOR = 1
        private var isOneShot = true
        private var hasBeenPerformed = false
    }


}<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
  >

<!--    <amplify.fill.customView.SplashView-->
<!--        android:id="@+id/splash_view"-->
<!--        android:layout_width="match_parent"-->
<!--        android:layout_height="match_parent"-->
<!--        app:holeFillColor="@color/colorPrimary"-->
<!--        app:icon="@drawable/ic_fill_new"-->
<!--        app:iconColor="@color/colorPrimary"-->
<!--        android:visibility="gone"-->
<!--        app:removeFromParentOnEnd="true" />-->
    <View
        android:id="@+id/splash_image_background"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:background="@color/white"/>

    <amplify.fill.customView.ResizeCallbackImageView
        android:id="@+id/splash_view1"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:scaleType="center"
        tools:background="@color/colorPrimary"
        tools:src="@drawable/ic_fill_new" />
</FrameLayout>
